# chapter 2
# 기본 문법 배우기
## 2-1 연산자 우선 순위
- 20 -> 가장 높음 1 -> 가장 나중에
- 20 : `() 그룹화`
- 19 : `., [], new, () 함수호출`
- 18 : `new(인수 없이)`
- 17 : `++(후위), --(후위)`
- 16 : `!, ~, +(단항), -(단항), ++(전위), --(전위), typeof, void, delete, await`
- 15 : `**`
- 14 : `*, /, %`
- 13 : `+(다항), -(다항)`
- 12 : `<<, >>, >>>`
- 11 : `<, <=, >, >=, in, instanceof`
- 10 : `==, !=, ===, !==`
- 09 : `&`
- 08 : `^`
- 07 : `|`
- 06 : `&&`
- 05 : `||`
- 04 : `? :` (삼항 연산자)
- 03 : `=, +=, -=, **=, *=, %=, /=, <<=, >>=, >>>=, &=, ^=, !=`
- 02 : `yield`, `yield*`
- 01 : `,`(쉼표)

## 실수 계산 시 주의할 점
- `0.1` + `0.2` =? 보통은 `0.3` 이라고 생각하지만
- 컴퓨터에선 `0.30000000000004` 라고 출력된다 
- why?
  *컴퓨터는 0과 1 밖에 모른다. 그런데 2진법을 실수를 표현하려고 하면 무한 반복되는 실수가 있어서 어쩔 수 없이 근삿값으로 저장함*
  그래서 우리가 사용하는 10진법으로 계산한 결과와 차이가 발생하는 경우가 발생
  -> **부동소수점 문제**
- 해결법
  - 가장 간단한 방법은 실수를 정수로 바꿔서 계산하고 마지막에 다시 실수로 바꾸는 법

## 문자의 번호 알아보기
- 문자의 번호를 알아보려면 charCodeAt을 사용한다.
- `'a'.charCodeAt();`
  - `97`

## == 과 === 차이 이해하기
- 값이 같은지 비교할 때 -- 연산자를 사용한다고 했지만
  - `'1' == 1;`
  -  `1  == true;`
  -  `1  == '1';`
- 자료형이 다르면 형 변환한 후 비교하기 때문에 앞의 예제에서는 모두 true가 출력됨
**`===` : 값만 비교하는것이 아닌 그 값의 자료형까지 비교하는 연산자** 
- `!=` 도 마찬가지로  `!==` 로 자료형 까지 비교가 가능하다

*따라서 == 와 != 대신 === 와 !== 연산자를 사용해 자료형까지 정확히 비교하기를 권장*

## 형 변환을 했을때 false 값을 가지는 값
- `!!false` : false    => !false->true => !true->**false**
- `!!''`    : '':false => !''->true    => !true->**false**
- `!!0`     : 0:false  => !0->true     => !true->**false**
- `!!NaN`   : NaN:false=> !NaN->true   => !true->**false**

- 이렇게 형 변환을 하였을 때 false가 되는 값을 **거짓인 값(falsy value)** 이라고 하고
- 이렇게 형 변환을 하였을 때 true 가 되는 값을 **참인 값(truthy value)** 이라고 함
- 논리 연산자들도 우선순위가 존재

# 빈 값 사용하기
## undefined 알아보기
- `undefined`는 보통 반환할 결과값이 없을 때 나온다
- `typeof undefined` => `undefined`
- undefined 를 boolean값으로 형 변환하면 false가 나온다
  - **단, undefined와 false는 같지 않다 거짓을 반환하는 다른 값들도 마찬가지**
  - `undefined == false;`
  - `undefined == 0;`
  - `undefined == '';`
  - **위 결과 값 모두 false**
  
## null 알아보기
- 다른 자료형으로는 `null`이 있음
- 빈 값을 의미하지만 `undefined` 와 같지는 않다
  - `undefined == null;` => true
  - `undefined === null;` => false
- `undefined` 와 마찬가지로 `null`도 `boolean`값으로 형 변환하면 `false`를 반환
  - `!!null;` => false
- 하지만 null은 false와 같지 않다 다른 거짓인 값들과도 같지 않다.
  - `null == false;`
  - `null == 0;`
  - `null == '';`
  - **위 결과 값 모두 false**
- `null` 자료형을 `typeof`로 확인해 보면 특이한 것을 발견할 수 있다
  - `typeof null;` => **"object"**
  - 결과 값이 "null"이 아니라 "object"이다.
  - 이 현상은 js의 유명한 버그이다
  - 원래는 "null"이 나와야 하지만 언어가 만들어진 초창기 실수 때문에 "object"가 되었음
  - 그 이후로는 바꿀 수 없게 되었다 ( 바꾸고 나면 기존 typeof null 식을 사용하는 모든 곳에 영향이 있기 때문)
  - 따라서 값이 null 인지 확인하기 위해서는 `=== null`을 사용해야합니다.
# 2.3 변수 : 값을 저장하고 저장한 값을 불러 올 수 있게 하는 수
- 선언(declaration) : 변수를 만드는 행위
- 변수 선언 방법 
  1. let
    - 형식
      - `let 변수명 = 식;`
  2. const
  3. var

- 변수를 선언할 때 변수에 값을 대입하지 않아도 된다.
- 하지만 값을 대입하지 않은 변수를 입력하면 `undefined`가 출력된다.
- 이미 선언한 변수를 다시 선언하면 에러가 발생함 -> 변수명이 겹치지 않게 주의
- *변수명으로 사용할 수 없는 단어도 존재*
  - `예약어(reserved word)`
  - JS Programming 에서 특정한 역할을 하므로 변수명으로 쓰지 않는다
  - ex) `let let = 'No!';` / `let var = 'No!';`
  - **예약어지만 변수명으로 쓸 수 있는 경우도 있고, 예약어가 아님에도 변수명으로 쓰지 못하는 경우도 존재**

## 변수의 값 수정하기
- 변수에 넣은 값을 비울 때 
  1. undefined 대입
    - `change = undefined;` => undefined
  2. null 대입
    - `change = null;` => null
- 대부분의 개발자가 null을 대입해 값을 의도적으로 지웠다는 의미를 부여합니다.

## 변수 활용하기
- 변수를 다른 변수에 대입할 수도 있다.

## 상수 만들기
- `let` 외에도 변수를 선언한느 예약어로 `const`와 `var`가 있다
- `const`는 *상수(constant)*
- 변수 `let` 은 *변하는 수* 이고 상수 `const`는 *변하지 않는 수*이다.
  
*상수와 변수는 반대 개념이지 않나?*
-> 상수와 변수의 뜻을 살펴보면 완전히 반대 개념이다
   하지만 왜 `let` `const` `var`를 한번에 묶어서 설명하는가?
   **const는 엄밀히 말하자면 상수가 아니기 때문**
   `const`는 나중에 배우는 객체의 내부 값에는 적용되지 않음

*상수를 사용하는 이유*
- 코딩을 하다 보면 변수의 값을 수정할 일이 생각보다 많지 않고 실수로 값을 수정하는 일을 막기 위해 상수를 사용
- 상수로 만들면 값이 수정되지 않음이 보장되기 때문에 더 안전하게 코딩할 수 있다
- `let` 은 처음 값을 대입한 후 다른 값을 대입해 수정할 수 있었지만
- `const`는 한번 값을 대입하면 다른것을 대입할 수 없다
- `const` 또한 식이 아니라 *선언문* 이기 때문에 console에 `undefined`가 출력된다
- `const` 로 선언한 상수도 다시 선언할 수 없다.
- 또한 한번 값을 대입하면 다른 값을 대입할 수 없다는 특성 때문에 상수 선언시 *초기화(선언 동시 값을 대입하는 것)를 하지않으면 에러가 발생*한다.

## var 알아보기
- `var` 는 변수(variable)의 줄임말이다.
- 예전에는 많이 사용하였지만 어려운 특성 때문에 const와 let을 사용해 변수를 선언하는 방식으로 옮겨 가고 있다
- `var`로 변수를 선언하면 특별히 **변수문(variable statement)** 이라고 한다.
- 선언 할 때 초기화 하지 않으면 `undefined`가 대입
- **기존에 선언했던 변수를 다시 선언해도 에러가 발생하지 않는다.**
- 이러한 특징 때문에 실수로 변수를 다시 선언하는 문제가 발생할 수 있다
- **또한 예약어나 다름없는 이름을 변수명으로 사용 할 수 있다.**

# 조건문
- 주어진 조건에 따라 코드를 실행하거나 실행하지 않는 문
- `if (로그인한 사용자)`
    `정보를 보여 준다;`
- if 뒤의 소괄호에는 조건(식)을 넣고, 다음 줄에 실행문을 넣으면 된다.
- 들여쓰기는 중요하지 않지만 가독성을 좋게 하기때문에 두칸을 띄워 쓴다
- if 형식
  `if (조건식)`
    `실행문;`

- 조건문은 조건식과 실행문으로 구분
- *조건식이 참인 값이면 내부의 실행문이 실행, 거짓이면 실행문이 실행되지 않음*
- 만약 실행문이 둘 이상이면 실행문들을 `{}` 중괄호로 감쌈
- 형식
  `if (조건식) {`
    `실행문1;`
    `실행문2;`
    `실행문3;`
  `}`

*실행문이 하나일 때는 중괄호를 사용하지 않아도 되지만, 하나일 때도 중괄호를 사용하기를 권장함*
- 가독성 및 코드를 해석 할 때 쉽게 볼 수 있다.

## else를 사용해 두 방향으로 분기하기
- 형식
  `if (조건식) { // 조건식이 참일 때 실행`
    `실행문;`
  `} else { // 조건식이 거짓일 때 실행`
    `실행문`
  `}`


## else if 를 사용해 여러 방향으로 분기하기
- `if-else` 문은 두 방향으로만 분기 하였지만
- `if-else if-else` 를 if문을 여러 방향으로 분기할 수 있다.
- 형식
  `if (조건식1) {`
    `실행문;`
  `} else if (조건식2) {`
    `실행문;`
  `} else if (조건식3) {`
    `실행문;`
  `} .... [ else {`
    `실행문;`
  `} ] // [] 부분은 생략이 가능하다. `

## 중첩 if문 사용하기
- if나 else, else if 문의 중괄호 안에 실행문을 넣을 수 있다는 사실을 활용할 수 있다. 
**하지만 중첩 if문은 피하는 것이 좋다**
- 중첩 if 문은 **논리적으로 if-else if-else 문으로 변환할 수 있다**
- 조건문이 중첩되어 들여쓰기가 깊어질수록 코드는 읽기 어려워진다.
- 따라서 중첩 if문을 if-else if-else문으로 변환해 코드의 *가독성을 높이기를 권장한다*

## switch 문으로 분기하기
- 조건문에는 if문 외에도 `switch`문이 존재
- `switch`문에는 조건식 두개가 사용된다.
- 형식
  switch (*조건식*) {
    case *비교 조건식*:
      실행문;
  }
- 보통 조건식 에 변수를 넣고, 비교 조건식에는 변수와 비교할 값을 넣는다.
- 실행문을 여러개 둘 수도 있다
- if문과 다르게 중괄호가 없어도 된다. 단 중괄호가 있는 것과 없는 것에는 차이가 있다
- if 문의 else if처럼 여러 방향으로 분기 할 수 있다
  - case를 여러번 사용하면 된다.
- **하지만 `break;` 문을 사용하지 않으면 만약 맨위의 `case`의 조건을 통과한 후 `break;` 문이 존재하지 않는다면 해당 `case` 밑의 조건들은 무시하고 나머지 `case`의 실행문들을 `break`문을 만날 때 까지 실행한다.**
- 어떠한 `case`도 일치하지 않을 때 실행하는 `case` 또한 만들 수 있다
- 단 이때는 `case` 대신 `default` 라는 특수한 예약어를 사용한다
- **`default`에는 `break`문을 붙이지 않아도 된다.**
  - 맨 마지막 case 이기 때문에 다음에 실행 될 것이 없기 때문
  - 하지만 default는 어디에나 위치할 수 있다.

## 조건부 연산자 사용하기
- if문과 switch문 외에도 분기 처리에 사용하는 식이 있다.
- 이를 `조건부 연산자` 또는 `삼항연산자`라고 하는 연산자로 표현합니다.
- 형식
  `조건식 ? 참일 때 실행되는 식 : 거짓일 때 실행되는 식`
- 조건부 연산자는 문이 아니라 식이므로 결과값이 나온다
- 조건부 연산은 **조건에 따라 달라지는 값을 변수에 대입할 때 사용한다**
- 조건부 연산 또한 `if`문으로 변경 가능
- 조건부 연산 또한 중첩해서 사용할 수 있다.
  - 중첩 해서 사용할 경우 들여쓰기로 구분해서 사용하는 편이 가독성이 좋다
  - 가독성을 위해 소괄호 연산자로 묶기도 한다
  ex)
      `condition1 ? 'condition1이 참' : condition2 ? 'condition2가 참' : '둘 다 거짓';`<br>
      이러한 식이 있을 경우 들여쓰기를 사용하면<br>
      `condition1`<br>
      ` ? 'condition1이 참'`<br>
      `   : condition2`<br>
      `   ? 'condition2가 참'`<br>
      `     : '둘 다 거짓';`<br>
      혹은 소괄호로 묶어
      `condition1 ? 'condition1이 참' : (condition2 ? 'condition2가 참' : '둘 다 거짓');`<br>
      처럼 표현 할 수 있다.

# 반복문
## while 문으로 Hello,while! 100번 출력하기
- 형식
  `while (조건식)`
    `실행문;`
- 조건식이 참일 동안 while문은 계속 반복된다.
- if 와 마찬가지로 실행문이 하나이더라도 중괄호로 묶는 것을 권장

## for 문으로 반복해서 출력하기
- 형식
  `for (시작; 조건식; 종료식)`
    `실행문;`
- 시작 부분이 먼저 실행 된 후 조건식, 실행문 , 종료식 순으로 실행됨
- 그 후 조건식을 다시 검사 한 후 참인 경우 다시 한번 더 같은 순으로 실행반복
- **for -> while / while -> for 문 바꿀 수 있어야한다**

## break문으로 반복문 멈추기
- 어떠한 특정한 조건에 종료를 시켜야할 때 `break`문을 사용하여 반복문을 탈출 시킬 수 있다.

## continue 문으로 코드 실행 건너뛰기
- 반복문이 특정 조건에서만 실행되기를 원할 때 주로 사용하며 `continue` 문을 넣으면 이후 코드는 건너뛰고 다음 반복이 실행

## 중첩 반복문 사용하기
- 반복문 안에 또다른 반복문이 존재하는 경우
- 반복문은 두 번 이상 중첩될 수도 있다

# 객체
- 객체는 자료형의 일종으로 다양한 값을 모아둔 또다른 값
- 객체의 종료
  - **배열 (array)**
  - **함수 (function)**
  - **배열이나 함수가 아닌 객체**
  
## 배열
- 배열은 내부의 값을 개별적으로 불러 올 수도 있다
- 배열 이름 뒤에 불로오고 싶은 값의 자릿수를 적어주면 된다
  - *자릿수는 0부터 시작한다*
  - 이러한 자릿수를 **인덱스(Index)**라고 부른다
- 배열 내 값의 자료형은 모두 같지 않아도 된다
- 배열 안에는 다른 배열이나 변수를 넣을 수도 있다
  - 이러한 배열을 **이차원배열** 이라고 부른다
- 배열의 내부의 값이 중복되어도 되고, 아무 값 없이 만들 수도 있다
  - 이런 배열 내부의 값을 **요소(element)**라고 한다.

### 배열의 요소 개수 구하기
- 배열 이름 뒤에 `.length`를 붙이면 배열의 요소들의 갯수를 알아볼수 있다.
- 형식
  `arrayName.length`
- 배열 요소의 갯수는 항상 배열의 마지막 인덱스 값보다 1크다

### 배열에 요소 추가하기
- 배열을 만들고 나면 중간에 배열을 수정할 수 있다
- 배열에 요소를 추가할 수도 있고, 특정 인덱스의 요소를 수정하거나 제거할 수도 있다
- `배열[원하는 위치] = 넣을 값` 이처럼 해서 인덱스에 요소를 대입하여 추가 할 수도 있지만
- 배열의 맨 앞에 값을 넣으려고 할때 `배열[0] = 'd'` 이처럼 하면 0번째 인덱스의 값이 'd' 로 바뀌며 배열에 요소로 변경이 된다.
  **그럼 어떻게 할까?**
  - `arr.unshift(원하는 값);` 라는 기능을 사용하면된다.
  - 주어진 값이 배열의 첫 번째 요소로 추가되고, 다른 요소들의 인덱스는 하나씩 뒤로 밀린다
  **맨뒤에 요소를 추가하고 싶다면?**
  - `배열[배열.length] = 값` 방식으로도 가능하지만
  - `arr.push(원하는 값);`를 사용하면 간단히 해결 가능하다.

**여기서 `const`로 배열을 지정하였는데도 수정이 가능했는데 그 이유는 무엇일까?**
- `const`에는 새로운 값을 대입(=) 하지 못한다고 기억하는게 좋다
**`const`에 객체(배열,함수,객체 리터럴)가 대입되면 객체 내부의 속성이나 배열의 요소값은 변경이 가능하다.**

### 배열에 요소 제거하기
- 요소를 제거하는 것은 상당히 복잡하다
- 어떤 요소를 제거한다면 그 뒤에 위치한 나머지 요소의 인덱스를 모두 1씩 앞으로 당겨야 하기 때문
- 하지만 배열에는 `pop()`,`shift()`,`splice()`이라는 배열 메소드를 지원한다.
- `pop()` 을 사용하면 배열의 마지막 요소가 제거된다.
- `shift()` 를 사용하면 배열의 첫 번째 요소가 제거된다.
- 반면 `splice()` 를 사용하면 원하는 요소를 원하는 만큼 제거가 가능한데다 제거한 위치에 다른 새로운 요소를 추가할 수 까지 있다.
  - `arr.splice("시작인덱스", ["제거할 요소 갯수", [추가할 요소 값1,...,추가할 요소 값n]]);`
  - *제거할 위치를 먼저 (시작인덱스) 선택한 뒤 제거할 요소의 갯수 만큼 제거한 후 만약 추가할 요소 값이      있다면 해당 위치에 (시작인덱스) 부터 추가해 준다.*

### 배열에서 요소 찾기
- 배열에 특정 요소가 있는지 찾는 기능인 `includes` 기능을 사용해보자 => 일종의 검색 기능이다. 
- `includes`의 **반환 값은 주어진 값이 배열 내 존재한다면 `true`를 존재하지 않는다면 `false`를 반환**한다
- 검색하고 싶은 값이 몇 번째 인덱스에 위치하는지도 알 수 있다.
  - `indexOf` 와 `lastIndexOf` 기능을 이용하면 된다.
- `indexOf` 는 배열의 앞에서 부터 `lastIndexOf`는 배열의 맨 뒤에서 부터 검색을 시작한다

#### 배열 반복하기
- 배열은 값들을 나열한 것이기 때문에 반복문과 같이 사용하는 경우가 많다
- `while`, `for`문 모두 사용 가능하다
- **배열에서 반복 기능을 제공하는 것이 아니라 반복문에 의해 반복되기 때문에 다른 기능을 추가하고 싶으면 반복문의 코드를 수정해야한다.**

## 함수
- 프로그래밍에서 함수(`function`)는 특정한 작업을 수행하는 코드를 의미한다.
- 함수를 미리 만들어 두고 원할 때 실행해 정해진 작업을 수행하게 할 수 있다.
- 함수를 만들 때는 보통 `function` 예약어를 사용하거나 => (화살표) 기호를 사용합니다.
- 화살표 기호를 사용한 함수를 `화살표 함수(arrow function)`라고 합니다.
- 형식
  `function(){}`
  or
  `() => {}`
  - 위 함수들은 이름이 없으므로 다른 곳에서 사용할 수 없다 함수에 이름을 붙이면 다른 곳에서 호출하여 사용할 수 있게 된다.
  `function a() {}` : 이처럼 함수를 상수에 대입하지 않고 function keyword 뒤에 함수 이름을 넣는 방식을 **함수 선언문(function declaration statement)**이라고 한다
  `const b = function() {};` 
  `const c = () => {};`
  : 위에 상수에 함수를 넣은 것처럼 함수를 상수나 변수에 대입하는 방식을 **함수 표현식(function expression)**이라고 한다
- 함수 a 를 선언한 후 a 뒤에 ()를 붙이면 함수가 실행 된다.

### return 이해하기
- 함수를 호출하면 항상 결과값이 나오는데 기본값으로 `undefined` 가 반환된다 이러한 값을 **반환값(return value)**이라고 한다.
- 예로 `console.log()` 함수를 호출하면 `undefined`가 나오는데 `console.log()` 함수의 반환값이 `undefined` 이기 때문이다.
- 함수의 반환값을 직접 정할 수도 있다
  - `return`문을 추가하면된다.
  - 함수의 반환값을 상수나 변수에 대입할 수도 있다. -> 함수의 반환값도 값이기 때문
- `return` 문의 기능은 이밖에 하나 더 있는데 바로 함수의 실행을 중간에 멈추는 역할을 해준다
  - `return` 문이 실행되면 그 아래 코드는 아예 실행되지 않는다
  - 이를 이용해 조건문과 `return`문을 결합해서 함수의 실행을 조작할 수 있다.

### 매개변수와 인수 사용하기
- 대표적으로 `console.log()` 함수를 호출할 때 소괄호 안에 값을 넣었는데 이 값을 `console.log` 함수가 받아서 콘솔에 출력한다. 여기서 알 수 있는 것은 함수에 원하는 아무 값이나 넣을 수 있다는 것이다.
- 여기서 *매개변수*와 *인수*의 관계가 나온다.<br>
  `function a(parameter) {`<br>
    `console.log(parameter);`<br>
  `}`<br>
  `a('argument');`<br>
  >> argument<br>
- 이처럼 함수를 호출할 때 넣은 `'argument'` 같은 값들을 *인수(argument)*라고 하고
- 함수를 선언할 때 사용한 `parameter` 같은 변수를 *매개변수(parameter)*라고 한다.
- 함수가 하나의 매개변수와 하나의 인수만을 가지는 것은 아니다
- 각각 여러 개를 가질 수 있고, 매개변수와 인수의 개수가 일치하지 않아도 된다.
  - 이 때 대응 되지 않는 매개변수에는 자동으로 `undefined` 값이 대입된다
- 이 처럼 매개변수와 인수의 개수가 일치하지 않을 수 있다
  - 따라서 *매개변수의 개수로 인수의 개수를 추정할 수는 없다*
  - 만약 인수가 몇 개 들어왔는지 궁금하다면 함수 내에서 `arguments`라는 값을 사용할 수 있다
    **하지만 화살표 함수 안에서는 `arguments`를 사용할 수 없다**
    - `arguments`는 `function`으로 선언한 함수에서만 사용할 수 있다.

### 다른 변수 사용하기
- 함수 안에서 변수나 상수를 선언할 수도 있다
- 또한, 함수 바깥에 위치한 변수나 상수를 사용할 수도 있다
- 자신의 매개변수나 내부 변수(또는 상수) 만 사용하는 함수를 **순수 함수** 라고 부른다
- 외부 변수(또는 상수)에 접근하고 있다면 그것은 **순수 함수** 라고 부를수 없다

### 객체 리터럴
- 객체는 여러 개의 변수를 하나의 변수로 묶을 때 사용한다
- 정보들은 {} 안에 묶여 있다
- 객체 내부에 사용되는 정보들을 속성(property)라고 하며
- 속성은 속성 이름과 속성 값으로 구분된다
- 이처럼 {}를 사용해 객체를 표현하는 것을 객체 리터럴 이라고 한다
- 형식
  `const 객체 = {`<br>
    `속성이름 : 속성값,`<br>
          `.`<br>
          `.`<br>
          `.`<br>
  `}`<br>
  - 속성이 여러개 있다면 쉼표(,)로 구분하면 된다
  `const 객체 = {`<br>
    `속성1이름 : 속성1값,`<br>
    `속성2이름 : 속성2값,`<br>
    `속성3이름 : 속성3값,`<br>
  `}`<br>
- **객체의 속성이 하나이든 여러 개이든 마지막 속성에도 끝에 쉼표를 넣어 주는것이 좋다**
  - git 과 같은 도구를 사용할 때 `add, commit, push` 를 할 때 줄 단위로 어떤 줄이 변경됐는지를 알려주는데
  - 쉼표를 사용하지 않으면 위에 쉼표를 붙이고 밑에 이어서 *속성을 추가해야 하기 때문에 git 변경줄이 쉼표를 붙였을 때와 한 줄 더 체크가 된다 그저 쉼표만 붙였는데 2개의 줄이 변경됐다고 표시하는 것이다.*
- 속성 이름은 문자열 이어야 하며, 속성 값은 자바스크립트의 모든 값이 들어갈 수 있다
- 변수를 통해 객체의 속성에 접근할 수 있다

**속성에 접근하는 방법**
1. `(.)` 온점을 통해 접근할 수 있다.
  - `변수.속성` 으로 접근할 수 있다
2. 배열처럼 `[]` 를 사용해 `변수[속성]` 과 같이 접근할 수 있다
  - 이 때 `[]` 내부에는 문자열이 들어가야한다. 
- 만약 존재하지 않는 속성에 접근하려고 하면 `undefined`를 반환한다

### 객체 속성 수정하기
- **`변수.속성 = 값;` 을 하면 주어진 값으로 속성이 바뀐다**

### 객체 속성 제거하기
- `delete 변수.속성;` 을 하면 해당 속성이 제거된다. 이 때 제거된 속성 값은 `undefined`가 된다
- `delete 변수['속성']` 또한 가능하다
**배열과 함수가 객체인 이유**
- 객체의 성질을 모두 다 사용할 수 있기 때문
- 배열과 함수에도 속성들을 추가하거나 수정 및 제거할 수도 있다
*객체는 함수와 배열을 포함하는 개념이라서 `{}` 를 사용해 만든 객체를 객체 리터럴이라고 따로 부르는 것이다*

### 메소드 이해하기
- 속성 값으로 자바 스크립트의 모든 값을 넣을 수 있다
- 객체의 속성 값을 함수가 들어가면 이 속성을 특별히 **메소드** 라고 한다

### 객체 간 비교하기
- 객체와 객체 사이에 비교연산을 할 때 실수를 가장 많이 한다
- ex)
      `{} === {}` >> false
- 객체가 아닌 숫자, 문자열, 불 값, null, undefined는 모두 true를 반환한다
- 객체는 모양이 같아도 생성할 때 마다 새로운 객체가 생성된다.
**따라서 같은 객체인지 비교하려면 기존 객체를 변수에 저장해 두어야한다.**

### 참조와 복사
**참조**
  - 객체를 사용할 때 반드시 알아야하는 개념인 참조(reference)라는 개념이다
  - a 라는 객체를 변수b에 대입하여 둘 다 (.) 을 사용해 접근하면 접근이 가능하며 둘의 값 또한 같은 값이 출력된다.
  - 이러한 상황을 변수 a 와 b가 같은 객체를 **참조**하고 있다고 표현한다
    - 또는 a와 b 그리고 **객체 간에 참조 관계**가 있다고 표현한다
**복사**
  - 객체가 아닌 값을 변수에 저장한 경우에는 참조관계가 생기지 않기 때문에 둘이 다른 값이 출력되며
  - 이렇게 참조가 생기지 않는 상황을 **복사(copy)** 라고 한다
